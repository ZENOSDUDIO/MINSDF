using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data;
using System.Xml.Serialization;
using System.IO;
using System.IO.Compression;
using System.ComponentModel;
using System.Reflection;

namespace SGM.Common.Utility
{
    public static class Utils
    {

        static bool IsNullableType(Type theType)
        {
            return (theType.IsGenericType && theType.GetGenericTypeDefinition().Equals(typeof(Nullable<>)));
        }

        static Type GetNullableUnderlyingType(Type nullableType)
        {
            NullableConverter nc = new NullableConverter(nullableType);
            return nc.UnderlyingType;
        }

        public static DataTable ListToDataTable2<T>(List<T> entitys)
        {
            Type entityType = entitys[0].GetType();
            List<PropertyInfo> entityProperties = entityType.GetProperties().ToList();
            List<Type> list = new List<Type>();
            foreach (var item in entityProperties)
            {
                if (!list.Contains(item.PropertyType))
                {
                    list.Add(item.PropertyType);
                }
            }


            string tableName = typeof(T).Name;

            DataTable table = new DataTable(tableName);
            
            DataColumn column = new DataColumn("AutoGeneratedSerialNo", typeof(int));
            column.ReadOnly = true;
            column.AutoIncrement = true;
            column.AutoIncrementSeed = 1;
            column.AutoIncrementStep = 1;
            table.Columns.Add(column);
            foreach (var property in entityProperties)
            {
                Type type = property.PropertyType;
                if (IsNullableType(type))
                {
                    type = GetNullableUnderlyingType(type);
                }
                if (!table.Columns.Contains(property.Name))
                {
                    table.Columns.Add(property.Name, type);
                }
                else
                {
                    table.Columns[property.Name].DataType = type;
                }
            }

            foreach (T item in entitys)
            {
                DataRow row = table.NewRow();
                foreach (var property in entityProperties)
                {
                    var fieldValue = property.GetValue(item, null);
                    if (fieldValue == null)
                    {
                        row[property.Name] = DBNull.Value;

                    }
                    else
                    {
                        row[property.Name] = fieldValue;
                    }
                }
                table.Rows.Add(row);
            }

            return table;
        }

        public static DataSet ListToDataSet<T>(List<T> entitys)
        {
           
            Type entityType = entitys[0].GetType();
            List<PropertyInfo> entityProperties = entityType.GetProperties().ToList();
            List<Type> list = new List<Type>();
            foreach (var item in entityProperties)
            {
                if (!list.Contains(item.PropertyType))
                {
                    list.Add(item.PropertyType);
                }
            }
            string str = SerializeToString(list.ToArray(), entitys);

           

            DataSet ds = new DataSet();

            using (StringReader reader = new StringReader(str))
            {
                ds.ReadXmlSchema(reader);
                reader.Close();
            }
            string tableName = typeof(T).Name;

            ds.Relations.Clear();
            for (int i = ds.Tables.Count - 1; i >= 0; i--)
            {
                DataTable table = ds.Tables[i];
                if (!string.Equals(table.TableName, tableName))
                {
                    table.Constraints.Clear();
                    ds.Tables.RemoveAt(i);
                }
                else
                {
                    DataColumn column = new DataColumn("AutoGeneratedSerialNo", typeof(int));
                    column.ReadOnly = true;
                    column.AutoIncrement = true;
                    column.AutoIncrementSeed = 1;
                    column.AutoIncrementStep = 1;
                    table.Columns.Add(column);
                }
            }
            foreach (var item in entityProperties)
            {
                Type type = item.PropertyType;
                if (IsNullableType(type))
                {
                    type = GetNullableUnderlyingType(type);
                }
                if (!ds.Tables[tableName].Columns.Contains(item.Name))
                {
                    ds.Tables[tableName].Columns.Add(item.Name, type);
                }
                else
                {
                    ds.Tables[tableName].Columns[item.Name].DataType = type;
                }
            }

            foreach (DataTable table in ds.Tables)
            {
                table.BeginLoadData();
            }
            
            using (StringReader reader = new StringReader(str))
            {
                ds.ReadXml(reader, XmlReadMode.IgnoreSchema);
                reader.Close();
            }
            foreach (DataTable table in ds.Tables)
            {
                table.EndLoadData();
            }
            return ds;
        }


        public static DataTable AddAutoIncreaseColumn(DataTable table, String columnName, int seed, int step)
        {
            DataColumn autoIncreaseColumn = new DataColumn(columnName, typeof(int));
            autoIncreaseColumn.AutoIncrement = true;
            autoIncreaseColumn.AutoIncrementSeed = seed;
            autoIncreaseColumn.AutoIncrementStep = step;
            autoIncreaseColumn.ReadOnly = true;


            DataTable tmpTable = table.Clone();
            tmpTable.PrimaryKey = null;

            DataTable result = new DataTable(table.TableName); result.Columns.Add(autoIncreaseColumn);
            DataColumn tmpCol;
            foreach (DataColumn col in table.Columns)
            {
                tmpCol = tmpTable.Columns[col.ColumnName];
                tmpTable.Columns.Remove(tmpCol);
                result.Columns.Add(tmpCol);
            }
            result.Merge(table);
            return result;
        }

        public static DataTable ListToDataTable<T>(List<T> entitys)
        {
            if (entitys == null || entitys.Count < 1)
            {
                throw new Exception("需转换的集合为空");
            }
            // get all Properties 
            Type entityType = entitys[0].GetType();
            List<PropertyInfo> entityProperties = entityType.GetProperties().ToList();

            //make table schema
            System.Data.DataTable dt = new System.Data.DataTable();
            for (int i = 0; i < entityProperties.Count; i++)
            {
                //convert into underlying type of nullable type as dataset doesn't support nullable type
                Type type = entityProperties[i].PropertyType;
                if (IsNullableType(type))
                {
                    type = GetNullableUnderlyingType(type);
                }
                DataColumn column = new DataColumn(entityProperties[i].Name, type);
                dt.Columns.Add(column);//entityProperties[i].Name);
            }

            var qry = entityProperties.AsQueryable();
            //convert entity to row
            foreach (object entity in entitys)
            {
                //ensure entity type
                if (entity.GetType() != entityType)
                {
                    throw new Exception("要转换的集合元素类型不一致");
                }
                DataRow row = dt.NewRow();
                foreach (DataColumn column in dt.Columns)
                {
                    PropertyInfo property = qry.FirstOrDefault(p => p.Name == column.ColumnName);
                    object obj = property.GetValue(entity, null);
                    if (property != null)
                    {

                        Type originalType = property.PropertyType;
                        if (IsNullableType(originalType))
                        {

                            Type type = GetNullableUnderlyingType(originalType);
                            NullableConverter c = new NullableConverter(originalType);
                            if (obj == null)//type.IsValueType&&
                            {
                                row[column.ColumnName] = DBNull.Value;

                            }
                            else
                            {
                                row[column.ColumnName] = obj;// c.ConvertTo(obj, type);
                            }
                        }
                        else
                        {
                            row[column.ColumnName] = obj;
                        }
                    }
                }
                dt.Rows.Add(row);

                //object[] entityValues = new object[entityProperties.Length];
                //for (int i = 0; i < entityProperties.Length; i++)
                //{
                //    PropertyInfo property = entityProperties[i];
                //    Type type=property.PropertyType;
                //    if (IsNullableType(type))
                //    {
                //        type = GetNullableUnderlyingType(type);
                //        if (type.IsValueType)
                //        {
                //            entityValues[i] = Activator.CreateInstance(type);

                //        }
                //        else
                //        { 
                //            entityValues[i] = property.GetValue(entity, null); }
                //    }
                //    else
                //    {
                //        entityValues[i] = entityProperties[i].GetValue(entity, null);
                //    }
                //}
                //dt.Rows.Add(entityValues);
            }
            return dt;
        }

        public static string SerializeToString<T>(Type[] extraTypes, T obj)
        {
            XmlSerializer xs = new XmlSerializer(typeof(T), extraTypes);
            string itemsStr = string.Empty;
            using (StringWriter sw = new StringWriter())
            {
                xs.Serialize(sw, obj);
                itemsStr = sw.ToString();
            }
            return itemsStr;
        }

        public static string SerializeToString<T>(T obj)
        {
            XmlSerializer xs = new XmlSerializer(typeof(T));
            string itemsStr = string.Empty;
            using (StringWriter sw = new StringWriter())
            {
                xs.Serialize(sw, obj);
                itemsStr = sw.ToString();
            }
            return itemsStr;
        }

        //public static byte[] Compress(string fileName)
        //{
        //    using (FileStream fs =File.OpenRead(fileName))
        //    {
        //        byte[] content = new byte[fs.Length];
        //        fs.Read(content, 0, content.Length);
        //        using (MemoryStream ms=new MemoryStream())
        //        {
        //        GZipStream zipStream = new GZipStream(ms, CompressionMode.Compress);
        //        }
        //        byte[] compressedContent;//=new byte[buffer.Length];
        //        zipStream.Write(compressedContent, 0, compressedContent.Length);
        //        buffer.Close();
        //        return compressedContent;
        //    }
        //}

        public static byte[] Compress(byte[] content)
        {
            using (MemoryStream buffer = new MemoryStream())
            {
                GZipStream zipStream = new GZipStream(buffer, CompressionMode.Compress);
                byte[] compressedContent;
                zipStream.Write(content, 0, content.Length);
                //buffer.Write(content, 0, content.Length);
                buffer.Seek(0, SeekOrigin.Begin);
                compressedContent = buffer.ToArray();
                buffer.Close();
                return compressedContent;
            }
        }

        public static byte[] DeCompress(byte[] compressedContent)
        {
            if (compressedContent != null)
            {
                using (GZipStream stream = new GZipStream(new MemoryStream(compressedContent), CompressionMode.Decompress))
                {
                    const int size = 4096;
                    byte[] buffer = new byte[size];
                    using (MemoryStream memory = new MemoryStream())
                    {
                        int count = 0;
                        do
                        {
                            count = stream.Read(buffer, 0, size);
                            if (count > 0)
                            {
                                memory.Write(buffer, 0, count);
                            }
                        }
                        while (count > 0);
                        return memory.ToArray();
                    }
                }
            }
            else
            {
                return null;
            }

        }

        public static IQueryable<E> GetQueryByPage<E>(IQueryable<E> query, int pageSize, int pageNumber, out int pageCount, out int itemCount)
        {
            itemCount = query.Count();

            pageCount = (itemCount - 1) / pageSize + 1;
            int rowSkip = pageSize * (pageNumber - 1);
            if (pageNumber > pageCount)
            {
                rowSkip = (pageCount - 1) * pageNumber;
            }
            return query.Skip(rowSkip).Take(pageSize);
        }

        public static decimal? GetDecimalDbCell(object cell)
        {
            decimal? cellValue = null;
            if (cell != DBNull.Value)
            {
                decimal tmp;
                if (decimal.TryParse(cell + "", out tmp))
                {
                    cellValue = tmp;
                }
            }
            return cellValue;
        }
    }

    public static class DataSetLinqOperators
    {
        public static DataTable CopyToDataTable<T>(IEnumerable<T> source)
        {
            return new ObjectShredder<T>().Shred(source, null, null);
        }


        public static DataTable CopyToDataTable<T>(IEnumerable<T> source,
                                                    DataTable table, LoadOption? options)
        {
            return new ObjectShredder<T>().Shred(source, table, options);
        }


    }


    public class ObjectShredder<T>
    {
        private FieldInfo[] _fi;
        private PropertyInfo[] _pi;
        private Dictionary<string, int> _ordinalMap;
        private Type _type;


        public ObjectShredder()
        {
            _type = typeof(T);
            _fi = _type.GetFields();
            _pi = _type.GetProperties();
            _ordinalMap = new Dictionary<string, int>();
        }


        public DataTable Shred(IEnumerable<T> source, DataTable table, LoadOption? options)
        {
            if (typeof(T).IsPrimitive)
            {
                return ShredPrimitive(source, table, options);
            }



            if (table == null)
            {
                table = new DataTable(typeof(T).Name);
            }


            // now see if need to extend datatable base on the type T + build ordinal map
            table = ExtendTable(table, typeof(T));


            table.BeginLoadData();
            using (IEnumerator<T> e = source.GetEnumerator())
            {
                while (e.MoveNext())
                {
                    if (options != null)
                    {
                        table.LoadDataRow(ShredObject(table, e.Current), (LoadOption)options);
                    }
                    else
                    {
                        table.LoadDataRow(ShredObject(table, e.Current), true);
                    }
                }
            }
            table.EndLoadData();
            return table;
        }


        public DataTable ShredPrimitive(IEnumerable<T> source, DataTable table, LoadOption? options)
        {
            if (table == null)
            {
                table = new DataTable(typeof(T).Name);
            }


            if (!table.Columns.Contains("Value"))
            {
                table.Columns.Add("Value", typeof(T));
            }


            table.BeginLoadData();
            using (IEnumerator<T> e = source.GetEnumerator())
            {
                Object[] values = new object[table.Columns.Count];
                while (e.MoveNext())
                {
                    values[table.Columns["Value"].Ordinal] = e.Current;


                    if (options != null)
                    {
                        table.LoadDataRow(values, (LoadOption)options);
                    }
                    else
                    {
                        table.LoadDataRow(values, true);
                    }
                }
            }
            table.EndLoadData();
            return table;
        }


        public DataTable ExtendTable(DataTable table, Type type)
        {
            // value is type derived from T, may need to extend table.
            foreach (FieldInfo f in type.GetFields())
            {
                if (!_ordinalMap.ContainsKey(f.Name))
                {
                    DataColumn dc = table.Columns.Contains(f.Name) ? table.Columns[f.Name]
                        : table.Columns.Add(f.Name, f.FieldType);
                    _ordinalMap.Add(f.Name, dc.Ordinal);
                }
            }
            foreach (PropertyInfo p in type.GetProperties())
            {


                if (!_ordinalMap.ContainsKey(p.Name))
                {


                    Type colType = p.PropertyType;


                    if ((colType.IsGenericType) && (colType.GetGenericTypeDefinition() == typeof(Nullable<>)))
                    {


                        colType = colType.GetGenericArguments()[0];


                    }


                    DataColumn dc = table.Columns.Contains(p.Name) ? table.Columns[p.Name]


                        : table.Columns.Add(p.Name, colType);


                    _ordinalMap.Add(p.Name, dc.Ordinal);


                }


            }
            return table;
        }


        public object[] ShredObject(DataTable table, T instance)
        {


            FieldInfo[] fi = _fi;
            PropertyInfo[] pi = _pi;


            if (instance.GetType() != typeof(T))
            {
                ExtendTable(table, instance.GetType());
                fi = instance.GetType().GetFields();
                pi = instance.GetType().GetProperties();
            }


            Object[] values = new object[table.Columns.Count];
            foreach (FieldInfo f in fi)
            {
                values[_ordinalMap[f.Name]] = f.GetValue(instance);
            }


            foreach (PropertyInfo p in pi)
            {
                values[_ordinalMap[p.Name]] = p.GetValue(instance, null);
            }
            return values;
        }
    }
}
